#ifndef PulseShapeFitOOTPileupCorrection_h
#define PulseShapeFitOOTPileupCorrection_h 1

#include <typeinfo>

#include "DataFormats/HcalDetId/interface/HcalDetId.h"
#include "CalibCalorimetry/HcalAlgos/interface/HcalPulseShapes.h"
#include "CalibFormats/HcalObjects/interface/HcalCoder.h"
#include "CalibFormats/HcalObjects/interface/HcalCalibrations.h"

#include <TMinuit.h>
#include "TFitterMinuit.h"

#include <TH1F.h>
#include "Minuit2/FCNBase.h"

namespace FitterFuncs{

   int cntNANinfit;
   double psFit_x[10], psFit_y[10], psFit_erry[10];

  // since we know we are counting in nanoseconds 
  // we don't need to do an expensive finding of the bin
  // simply take floor(x) and determine if bin center is above or below
  // bin center is just bin + 0.5, inputs bins are 1ns wide
   float fast_interpolate(double x, const std::array<float,256>& h1) {
      if( x != x ){
         cntNANinfit ++;
         return h1[255];
      }

      const int bin = (int)x;

      if( x < 0.5 ) return h1[0];
      else if ( x > 255.5 ) return h1[255];

      const int bin_0 = ( x < bin+0.5 ? bin-1 : bin );
      const int bin_1 = ( x < bin+0.5 ? bin : bin+1 );
    
      const float slope = (h1[bin_1] - h1[bin_0])/(bin_1-bin_0);
      return h1[bin_0] + (x-bin_0-0.5f)*slope;
   }

   std::array<float,10> funcHPDShape(const std::vector<double>& pars,
                                     const std::array<float,256>& h1_single) {
    // pulse shape components over a range of time 0 ns to 255 ns in 1 ns steps
      constexpr int ns_per_bx = 25;
      constexpr int num_ns = 250;
      constexpr int num_bx = num_ns/ns_per_bx;

    // zeroing output binned pulse shape 
      std::array<float,num_bx> ntmpbin{ {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f} };

      for(int i=0;i < num_ns; ++i) {
         const float offset = i - 98.5f - pars[0]; // where does 98.5 come from?
         const float shifted_pulse1 = (offset < 0.0f ? 0.0f : fast_interpolate(offset,h1_single));
         ntmpbin[i/ns_per_bx] += shifted_pulse1;
      }
    // now we use ntmpbin to record the final pulse shape
      for(int i=0; i < num_bx; ++i) {
         ntmpbin[i] = pars[1]*ntmpbin[i] + pars[2];
      }
      return ntmpbin;
   }

   std::array<float,10> func_DoublePulse_HPDShape(const std::vector<double>& pars,
                                                  const std::array<float,256>& h1_double) {
    // pulse shape components over a range of time 0 ns to 255 ns in 1 ns steps
      constexpr int ns_per_bx = 25;
      constexpr int num_ns = 250;
      constexpr int num_bx = num_ns/ns_per_bx;

    // zeroing output binned pulse shape
      std::array<float,num_bx> ntmpbin{ {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f} };
      std::array<float,num_bx> ntmpbin2{ {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f} };

      for(int i=0;i < num_ns;++i) {
         const float offset1 = i - 98.5 - pars[0]; // where does 98.5 come from?
         const float offset2 = i - 98.5 - pars[1];

         ntmpbin[i/ns_per_bx] += (offset1 < 0.0f ? 0.0f : fast_interpolate(offset1,h1_double));
         ntmpbin2[i/ns_per_bx] += (offset2 < 0.0f ? 0.0f : fast_interpolate(offset2,h1_double));
      }
    // now we use ntmpbin to record the final pulse shape
      for(int i=0; i < num_bx; ++i) {
         ntmpbin[i] = pars[2]*ntmpbin[i]+pars[3]*ntmpbin2[i]+pars[4];
      }
      return ntmpbin;
   } 

   class SinglePulseShapeFunctor {
      public:
         SinglePulseShapeFunctor(const HcalPulseShapes::Shape& pulse);
         ~SinglePulseShapeFunctor();
         double operator()(const std::vector<double>& pars) const;
      private:
         std::array<float,256> pulse_hist;
   };
   
   class DoublePulseShapeFunctor {
      public:
         DoublePulseShapeFunctor(const HcalPulseShapes::Shape& pulse);
         ~DoublePulseShapeFunctor();
         double operator()(const std::vector<double> & pars) const;
      private:
         std::array<float,256> pulse_hist;
   };
   
   // because minuit owns the function you pass it?
   template<typename PSF>
   class PulseShapeFCN : public ROOT::Minuit2::FCNBase {
      public:
          PulseShapeFCN(const PSF* t) { psf_ = t; }
          double operator()(const std::vector<double>& pars) const {
             return (*psf_)(pars);
          }
          double Up() const { return 1.; }
      private:
         const PSF* psf_;
   };
   
   SinglePulseShapeFunctor::SinglePulseShapeFunctor(const HcalPulseShapes::Shape& pulse) {
      for(int i=0;i<256;i++) {
         pulse_hist[i] = pulse(i);
      }
   }
   
   SinglePulseShapeFunctor::~SinglePulseShapeFunctor() {
   }
   
   double SinglePulseShapeFunctor::operator()(const std::vector<double>& pars) const {
      constexpr unsigned nbins = 10;
      unsigned i;
   
      //calculate chisquare
      double chisq = 0;
      double delta;
      std::array<float,nbins> pulse_shape = std::move(funcHPDShape(pars,pulse_hist));
      for (i=0;i<nbins; ++i) {
         delta = (psFit_y[i]- pulse_shape[i])/psFit_erry[i];
         chisq += delta*delta;
      }
      return chisq;
   }
   
   DoublePulseShapeFunctor::DoublePulseShapeFunctor(const HcalPulseShapes::Shape& pulse) {
      for(int i=0;i<256;i++) {
         pulse_hist[i] = pulse(i);
      }
   }
   
   DoublePulseShapeFunctor::~DoublePulseShapeFunctor() {
   }

   double DoublePulseShapeFunctor::operator()(const std::vector<double>& pars) const {
      constexpr unsigned nbins = 10;
      unsigned i;

      //calculate chisquare
      double chisq = 0;
      double delta;
      //double val[1];
      std::array<float,nbins> pulse_shape = std::move(func_DoublePulse_HPDShape(pars,pulse_hist));
      for (i=0;i<nbins; ++i) {
         delta = (psFit_y[i]- pulse_shape[i])/psFit_erry[i];
         chisq += delta*delta;
      }
      return chisq;
   }

}

class PulseShapeFitOOTPileupCorrection
{
public:
    PulseShapeFitOOTPileupCorrection();
    inline ~PulseShapeFitOOTPileupCorrection() {}

    // Main correction application method to be implemented by
    // derived classes. Arguments are as follows:
    //
    //
    // Some of the input arguments may be ignored by derived classes.
    //
    template<class Digi> void apply(const Digi & digi, const HcalCoder & coder,
                       const HcalCalibrations & calibs, std::vector<double> & correctedOutput) const;

    // Comparison operators. Note that they are not virtual and should
    // not be overriden by derived classes. These operators are very
    // useful for I/O testing.
    inline bool operator==(const PulseShapeFitOOTPileupCorrection& r) const
        {return (typeid(*this) == typeid(r)) && this->isEqual(r);}
    inline bool operator!=(const PulseShapeFitOOTPileupCorrection& r) const
        {return !(*this == r);}

    void setPulseShapeTemplate(const HcalPulseShapes::Shape& ps) {
       spsf_.reset(new FitterFuncs::SinglePulseShapeFunctor(ps));
       dpsf_.reset(new FitterFuncs::DoublePulseShapeFunctor(ps));
    }

protected:
    // Method needed to compare objects for equality.
    bool isEqual(const PulseShapeFitOOTPileupCorrection&) const;

private:
//    HcalPulseShapes theHcalPulseShapes_;

    std::auto_ptr<FitterFuncs::SinglePulseShapeFunctor> spsf_;
    std::auto_ptr<FitterFuncs::DoublePulseShapeFunctor> dpsf_;

    bool useDataPulseShape_;

    int pulseShapeFit(const std::vector<double> & energyVec, const std::vector<double> & pedenVec, const std::vector<double> &chargeVec, const std::vector<double> &pedVec, const double TSTOTen, std::vector<double> &fitParsVec, const std::auto_ptr<FitterFuncs::SinglePulseShapeFunctor>& spsf, const std::auto_ptr<FitterFuncs::DoublePulseShapeFunctor>& dpsf) const;
};

#endif // PulseShapeFitOOTPileupCorrection_h
