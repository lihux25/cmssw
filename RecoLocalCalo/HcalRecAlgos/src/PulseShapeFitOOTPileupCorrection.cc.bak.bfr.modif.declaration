#include <climits>
#include "RecoLocalCalo/HcalRecAlgos/interface/PulseShapeFitOOTPileupCorrection.h"

PulseShapeFitOOTPileupCorrection::PulseShapeFitOOTPileupCorrection()
{
}

template<class Digi> void PulseShapeFitOOTPileupCorrection::apply(const Digi & digi, const HcalCoder & coder,
                       const HcalCalibrations & calibs, std::vector<double> & correctedOutput) const
{
   FitterFuncs::cntNANinfit = 0;

   CaloSamples cs;
   coder.adc2fC(digi,cs);
   std::vector<double> chargeVec, pedVec;
   std::vector<double> energyVec, pedenVec;
   double TSTOT = 0, TStrig = 0; // in fC
   double TSTOTen = 0; // in GeV
   for(int ip=0; ip<cs.size(); ip++){
      const int capid = digi[ip].capid();
      double charge = cs[ip];
      double ped = calibs.pedestal(capid);
      double gain = calibs.respcorrgain(capid);

      double energy = charge*gain;
      double peden = ped*gain;

      chargeVec.push_back(charge); pedVec.push_back(ped);
      energyVec.push_back(energy); pedenVec.push_back(peden);

      TSTOT += charge - ped;
      TSTOTen += energy - peden;
      if( ip ==4 ){
         TStrig = charge - ped;
      }
   }
   std::vector<double> fitParsVec;
   if( TStrig >= 4 && TSTOT >= 10 ){
      pulseShapeFit(energyVec, pedenVec, chargeVec, pedVec, TSTOTen, fitParsVec, spsf_, dpsf_);
//      time = fitParsVec[1]; ampl = fitParsVec[0]; uncorr_ampl = fitParsVec[0];
   }
   correctedOutput.swap(fitParsVec); correctedOutput.push_back(FitterFuncs::cntNANinfit);
}

int PulseShapeFitOOTPileupCorrection::pulseShapeFit(const std::vector<double> & energyVec, const std::vector<double> & pedenVec, const std::vector<double> &chargeVec, const std::vector<double> &pedVec, const double TSTOTen, std::vector<double> &fitParsVec, const std::auto_ptr<FitterFuncs::SinglePulseShapeFunctor>& spsf, const std::auto_ptr<FitterFuncs::DoublePulseShapeFunctor>& dpsf) const{

   int n_max=0;
   int n_above_thr=0;
   int first_above_thr_index=-1;
   int max_index[10]={0,0,0,0,0,0,0,0,0,0};

   double TSMAX=0;
   double TSMAX_NOPED=0;
   int i_tsmax=0;

   for(int i=0;i<10;i++){
      if(energyVec[i]>TSMAX){
         TSMAX=energyVec[i];
         TSMAX_NOPED=energyVec[i]-pedenVec[i];
         i_tsmax = i;
      }
   }

   double TIMES[10]={-100,-75,-50,-25,0,25,50,75,100,125};

   if(n_max==0){
      max_index[0]=i_tsmax;
   }

   double error = 1.;
   for(int i=0;i<10;i++){
      FitterFuncs::psFit_x[i]=i;
      FitterFuncs::psFit_y[i]=energyVec[i];
      FitterFuncs::psFit_erry[i]=error;
   }

   TFitterMinuit * gMinuit = new TFitterMinuit();
   gMinuit->SetPrintLevel(-1);

   for(int i=0;i!=10;++i){
      if((chargeVec[i])>6){
         n_above_thr++;
         if(first_above_thr_index==-1){
            first_above_thr_index=i;
         }
      }
   }

   // Fixed Maximum Finder
   for( int i=0 ; i < 10; ++i ) {
      switch( i ) {
         case 0:
            if(chargeVec[i]<=6 && chargeVec[i+1]<=6) continue;
            if( chargeVec[i+1] < chargeVec[i] ) {
               max_index[n_max++] = i;
            }
            break;
         case 9:
            if(chargeVec[i]<=6 && chargeVec[i-1]<=6) continue;
            if( chargeVec[i-1] < chargeVec[i] ) {
               max_index[n_max++] = i;
            }
            break;
         default:
            if(chargeVec[i-1]<=6 && chargeVec[i]<=6 && chargeVec[i+1]<=6) continue;
            if( chargeVec[i-1] < chargeVec[i] && chargeVec[i+1] < chargeVec[i]) {
               max_index[n_max++] = i;
            }
            break;
         }
      }

      if(n_max==0){
         max_index[0]=i_tsmax;
        //n_max=1; // there's still one max if you didn't find any...
      }

      if(n_above_thr<=5){
         FitterFuncs::PulseShapeFCN<FitterFuncs::SinglePulseShapeFunctor>* temp = new FitterFuncs::PulseShapeFCN<FitterFuncs::SinglePulseShapeFunctor>(spsf.get());
         gMinuit->SetMinuitFCN(temp); // bai bai!

         // Set starting values and step sizes for parameters
         double vstart[3] = {TIMES[i_tsmax-1],TSMAX_NOPED,0};
         double step[3] = {0.1,0.1,0.1};
         gMinuit->Clear();
         gMinuit->SetParameter(0, "time", vstart[0], step[0], -100,75);
         gMinuit->SetParameter(1, "energy", vstart[1], step[1], 0,TSTOTen);
         gMinuit->SetParameter(2, "ped", vstart[2], step[2], 0,TSTOTen);
         double chi2=9999.;
         for(int tries=0; tries<=3;tries++){
            // Now ready for minimization step
            gMinuit->CreateMinimizer( TFitterMinuit::kMigrad );
            gMinuit->Minimize();

            double chi2valfit,edm,errdef;
            int nvpar,nparx;
            gMinuit->GetStats(chi2valfit,edm,errdef,nvpar,nparx);

            if(chi2>chi2valfit+0.01) {
               chi2=chi2valfit;
               if(tries==0){
                  gMinuit->CreateMinimizer( TFitterMinuit::kScan );
                  gMinuit->Minimize();
               } else if(tries==1){
                  gMinuit->SetStrategy(1);
               } else if(tries==2){
                  gMinuit->SetStrategy(2);
               }
            } else {
               break;
            }
         }
      } else {
         FitterFuncs::PulseShapeFCN<FitterFuncs::DoublePulseShapeFunctor>* temp = new FitterFuncs::PulseShapeFCN<FitterFuncs::DoublePulseShapeFunctor>(dpsf.get());
         gMinuit->SetMinuitFCN(temp); // bai bai!

         if(n_max==1){
            // Set starting values and step sizes for parameters
            double vstart[5] = {TIMES[i_tsmax-1],TIMES[first_above_thr_index-1],TSMAX_NOPED,0,0};

            Double_t step[5] = {0.1,0.1,0.1,0.1,0.1};
            gMinuit->Clear();
            gMinuit->SetParameter(0, "time1", vstart[0], step[0], -100,75);
            gMinuit->SetParameter(1, "time2", vstart[1], step[1], -100,75);
            gMinuit->SetParameter(2, "energy1", vstart[2], step[2], 0,TSTOTen);
            gMinuit->SetParameter(3, "energy2", vstart[3], step[3], 0,TSTOTen);
            gMinuit->SetParameter(4, "ped", vstart[4], step[4], 0,TSTOTen);

            double chi2=9999.;
            for(int tries=0; tries<=3;tries++) {
            // Now ready for minimization step
               gMinuit->CreateMinimizer( TFitterMinuit::kMigrad );
               gMinuit->Minimize();

               double chi2valfit,edm,errdef;
               int nvpar,nparx;
               gMinuit->GetStats(chi2valfit,edm,errdef,nvpar,nparx);

               if(chi2>chi2valfit+0.01) {
                  chi2=chi2valfit;
                  if(tries==0){
                     gMinuit->CreateMinimizer( TFitterMinuit::kScan );
                     gMinuit->Minimize();
                } else if(tries==1) {
                   gMinuit->SetStrategy(1);
                } else if(tries==2) {
                   gMinuit->SetStrategy(2);
                }
              } else {
                 break;
              }
           }
        } else if(n_max>=2) {
           // Set starting values and step sizes for parameters
           double vstart[5] = {TIMES[max_index[0]-1],TIMES[max_index[1]-1],TSMAX_NOPED,0,0};

           double step[5] = {0.1,0.1,0.1,0.1,0.1};
           gMinuit->Clear();
           gMinuit->SetParameter(0, "time1", vstart[0], step[0], -100,75);
           gMinuit->SetParameter(1, "time2", vstart[1], step[1], -100,75);
           gMinuit->SetParameter(2, "energy1", vstart[2], step[2], 0,TSTOTen);
           gMinuit->SetParameter(3, "energy2", vstart[3], step[3], 0,TSTOTen);
           gMinuit->SetParameter(4, "ped", vstart[4], step[4], 0,TSTOTen);

           double chi2=9999.;
           for(int tries=0; tries<=3;tries++) {
           // Now ready for minimization step
              gMinuit->CreateMinimizer( TFitterMinuit::kMigrad );
              gMinuit->Minimize();

              double chi2valfit,edm,errdef;
              int nvpar,nparx;

              gMinuit->GetStats(chi2valfit,edm,errdef,nvpar,nparx);

              if(chi2>chi2valfit+0.01) {
                 chi2=chi2valfit;
                 if(tries==0){
                    gMinuit->CreateMinimizer( TFitterMinuit::kScan );
                    gMinuit->Minimize();
                 } else if(tries==1) {
                    gMinuit->SetStrategy(1);
                 } else if(tries==2) {
                    gMinuit->SetStrategy(2);
                 }
              } else {
                 break;
              }
           }
        }
     }

     double timeval1fit=-999;
     double chargeval1fit=-999;
     double timeval2fit=-999;
     double chargeval2fit=-999;
     double pedvalfit=-999;

     if(n_above_thr<=5) {
        timeval1fit = gMinuit->GetParameter(0);
        chargeval1fit = gMinuit->GetParameter(1);
        pedvalfit = gMinuit->GetParameter(2);
     } else {
        timeval1fit = gMinuit->GetParameter(0);
        timeval2fit = gMinuit->GetParameter(1);
        chargeval1fit = gMinuit->GetParameter(2);
        chargeval2fit = gMinuit->GetParameter(3);
        pedvalfit = gMinuit->GetParameter(4);
     }

     double chi2valfit,edm,errdef;
     int nvpar,nparx;
     int fitStatus = gMinuit->GetStats(chi2valfit,edm,errdef,nvpar,nparx);

     double timevalfit=0.;
     double chargevalfit=0.;
     if(n_above_thr<=5) {
        timevalfit=timeval1fit;
        chargevalfit=chargeval1fit;
     } else {
        if(fabs(timeval1fit)<fabs(timeval2fit)) {// if timeval1fit and timeval2fit are differnt, choose the one which is closer to zero
           timevalfit=timeval1fit;
           chargevalfit=chargeval1fit;
        } else if(fabs(timeval2fit)<fabs(timeval1fit)) {// if timeval1fit and timeval2fit are differnt, choose the one which is closer to zero
           timevalfit=timeval2fit;
           chargevalfit=chargeval2fit;
        } else if(timeval1fit==timeval2fit) { // if the two times are the same, then for charge we just sum the two  
           timevalfit=(timeval1fit+timeval2fit)/2;
           chargevalfit=chargeval1fit+chargeval2fit;
        } else {
           timevalfit=-999.;
           chargevalfit=-999.;
        }
     }

     if( gMinuit ) delete gMinuit;

     fitParsVec.clear();

     fitParsVec.push_back(chargevalfit);
     fitParsVec.push_back(timevalfit);
     fitParsVec.push_back(pedvalfit);
     fitParsVec.push_back(chi2valfit);

     return fitStatus;
}
